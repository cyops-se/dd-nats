package ddmb

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"math/rand"
	"net"
	"net/url"
	"strings"
	"sync"
	"time"

	mqtt "github.com/eclipse/paho.golang/paho"
)

type MqttRequestHandle struct {
	id  string
	mch chan *mqtt.PublishReceived
}

type MqttWildcardEntry struct {
	topic   string
	prefix  string
	handler IMessageHandler
}

type MqttMessageBroker struct {
	Error            error
	ConnectionURL    string
	NetCon           net.Conn
	MqttClient       *mqtt.Client
	MqttCon          *mqtt.Connack
	Handlers         map[string]IMessageHandler
	WildcardHandlers []MqttWildcardEntry
	RequestHandles   map[string]MqttRequestHandle
	mutex            sync.Mutex
}

var letters = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

func makeid(n int) string {
	b := make([]rune, n)
	for i := range b {
		b[i] = letters[rand.Intn(len(letters))]
	}
	return string(b)
}

func NewMqttBroker() IMessageBroker {
	mb := new(MqttMessageBroker)
	mb.Handlers = make(map[string]IMessageHandler)
	mb.WildcardHandlers = make([]MqttWildcardEntry, 0)
	mb.RequestHandles = make(map[string]MqttRequestHandle)
	return mb
}

func (mb *MqttMessageBroker) Connect(connectionUrl string) error {

	lu, err := url.Parse(connectionUrl)
	if err != nil {
		log.Fatalf("Unable to parse provided URL %s, error: %s", connectionUrl, err)
	}

	mb.ConnectionURL = connectionUrl
	server := lu.Host

	mb.NetCon, mb.Error = net.Dial("tcp", server)
	for mb.Error != nil {
		log.Printf("Failed to connect to MQTT server, retrying in 5 seconds, error: %s", mb.Error.Error())
		time.Sleep(5 * time.Second)
		mb.NetCon, mb.Error = net.Dial("tcp", server)
	}

	log.Printf("New client at %s", server)
	mb.MqttClient = mqtt.NewClient(mqtt.ClientConfig{
		OnPublishReceived: []func(mqtt.PublishReceived) (bool, error){
			func(pr mqtt.PublishReceived) (bool, error) {
				if strings.HasPrefix(pr.Packet.Topic, "_INBOX_") {
					// The topic is autogenerated for the response message in req/resp pattern
					if requesthandle, ok := mb.RequestHandles[pr.Packet.Topic]; ok {
						requesthandle.mch <- &pr
						delete(mb.RequestHandles, requesthandle.id)
					}
				} else if handler, ok := mb.Handlers[pr.Packet.Topic]; ok {
					// Unfortunatley, we have to adapt to the NATS path specification again since all apps must use it
					topic := strings.ReplaceAll(pr.Packet.Topic, "/", ".")
					if err := handler(topic, pr.Packet.Properties.ResponseTopic, pr.Packet.Payload); err != nil {
						log.Printf("MQTT framework internal error processing message, topic: '%s', error: '%s'", topic, err.Error())
					}
				} else if handler, ok = mb.Handlers["#"]; ok {
					// Unfortunatley, we have to adapt to the NATS path specification again since all apps must use it
					topic := strings.ReplaceAll(pr.Packet.Topic, "/", ".")
					if err := handler(topic, pr.Packet.Properties.ResponseTopic, pr.Packet.Payload); err != nil {
						log.Printf("MQTT framework internal error processing message, topic: '%s', error: '%s'", topic, err.Error())
					}
				} else if handler, ok = mb.checkWildcard(pr.Packet.Topic); ok {
					// Wild card handler
					topic := strings.ReplaceAll(pr.Packet.Topic, "/", ".")
					if err := handler(topic, pr.Packet.Properties.ResponseTopic, pr.Packet.Payload); err != nil {
						log.Printf("MQTT framework internal error processing message, wildcard topic: '%s', error: '%s'", topic, err.Error())
					}
				} else {
					log.Printf("UNHANDLED message received: %s : %s", pr.Packet.Topic, string(pr.Packet.Payload))
				}

				return true, nil
			}},
		OnClientError: func(err error) {
			fmt.Printf("Client error detected: %s\n", err.Error())
			if mb.mutex.TryLock() {
				mb.reconnect()
			}
		},
		OnServerDisconnect: func(d *mqtt.Disconnect) {
			if d.Properties != nil {
				fmt.Printf("server requested disconnect: %s\n", d.Properties.ReasonString)
			} else {
				fmt.Printf("server requested disconnect; reason code: %d\n", d.ReasonCode)
			}
		},
		Conn: mb.NetCon,
	})

	log.Printf("Connecting %s", server)
	cp := &mqtt.Connect{KeepAlive: 30, CleanStart: false, UsernameFlag: false, PasswordFlag: false}

	mb.MqttCon, mb.Error = mb.MqttClient.Connect(context.Background(), cp)
	if mb.Error != nil {
		log.Printf("Failed to connect to MQTT server, fatal error: %s", mb.Error)
		log.Fatalln(mb.Error)
	}

	for mb.MqttCon.ReasonCode != 0 {
		log.Printf("Failed to connect to MQTT server, retrying in 5 seconds, error: %s", mb.MqttCon.Properties.ReasonString)
		time.Sleep(5 * time.Second)
		mb.MqttCon, _ = mb.MqttClient.Connect(context.Background(), cp)
	}

	log.Printf("Connected to MQTT server: %s", connectionUrl)

	return nil
}

func (mb *MqttMessageBroker) reconnect() {
	log.Printf("Attempting to reconnect")
	mb.MqttClient.Disconnect(&mqtt.Disconnect{ReasonCode: 0}) // Hopefully cleans up stuff
	mb.MqttClient = nil

	if mb.Connect(mb.ConnectionURL) == nil && mb.Error == nil {
		log.Printf("mqtt connection re-established, re-subscribing topics")
		for topic := range mb.Handlers {
			log.Printf("resubscribing regular topic: %s", topic)
			_, mb.Error = mb.MqttClient.Subscribe(context.Background(), &mqtt.Subscribe{
				Subscriptions: []mqtt.SubscribeOptions{
					{Topic: topic, QoS: 0, NoLocal: true},
				},
			})
		}

		for _, entry := range mb.WildcardHandlers {
			log.Printf("resubscribing wildcard topic: %s", entry.topic)
			_, mb.Error = mb.MqttClient.Subscribe(context.Background(), &mqtt.Subscribe{
				Subscriptions: []mqtt.SubscribeOptions{
					{Topic: entry.topic, QoS: 0, NoLocal: true},
				},
			})
		}
	}

	mb.mutex.Unlock()
}

func (mb *MqttMessageBroker) Disconnect() error {
	return nil
}

func (mb *MqttMessageBroker) Publish(topic string, data interface{}) error {
	return mb.PublishWithReponse(topic, "", data)
}

func (mb *MqttMessageBroker) PublishWithReponse(topic string, responseTopic string, data interface{}) error {
	if mb.MqttClient == nil {
		return fmt.Errorf("failed to publish message to subject '%s': No connection to MQTT", topic)
	}

	var payload []byte
	var err error

	if _, ok := data.([]byte); ok {
		payload = data.([]byte)
	} else {
		payload, err = json.Marshal(data)
		if err != nil {
			return fmt.Errorf("failed to publish subject '%s': %s", topic, err.Error())
		}
	}

	// Make topic MQTT
	topic = strings.ReplaceAll(topic, ".", "/") // As dot '.' is default topic separator, we need to MQTTify it

	pb := &mqtt.Publish{
		Topic:   topic,
		Payload: payload,
		QoS:     0,
	}

	if responseTopic != "" {
		pb.Properties = &mqtt.PublishProperties{ResponseTopic: responseTopic}
	}

	_, mb.Error = mb.MqttClient.Publish(context.Background(), pb)
	return mb.Error
}

// There is no native request/response functions in paho
func (mb *MqttMessageBroker) Request(topic string, data interface{}) ([]byte, error) {
	if mb.MqttClient == nil {
		return nil, fmt.Errorf("failed to publish message to subject '%s': No connection to MQTT", topic)
	}

	id := "_INBOX_" + makeid(32)
	mch := make(chan *mqtt.PublishReceived, 8)
	mb.RequestHandles[id] = MqttRequestHandle{id: id, mch: mch}

	_, mb.Error = mb.MqttClient.Subscribe(context.Background(), &mqtt.Subscribe{
		Subscriptions: []mqtt.SubscribeOptions{
			{Topic: id, QoS: 0, NoLocal: true},
		},
	})

	mb.PublishWithReponse(topic, id, data)

	t := time.NewTimer(2 * time.Second)
	select {
	case pr := <-mch:
		unsub := &mqtt.Unsubscribe{Topics: []string{id}}
		mb.MqttClient.Unsubscribe(context.Background(), unsub)
		return pr.Packet.Payload, nil

	case <-t.C:
		break
	}

	return nil, fmt.Errorf("request timed out")
}

func (mb *MqttMessageBroker) Subscribe(topic string, callback IMessageHandler) error {
	if mb.MqttClient == nil {
		return fmt.Errorf("failed to subscribe to subject '%s': No connection to MQTT", topic)
	}

	// Make topic MQTT and trim the "#" wildcard
	topic = strings.ReplaceAll(topic, ".", "/") // As dot '.' is default topic separator, we need to MQTTify it
	topic = strings.ReplaceAll(topic, ">", "#") // As dot '>' is default remaining path wildcard, we need to MQTTify it

	_, mb.Error = mb.MqttClient.Subscribe(context.Background(), &mqtt.Subscribe{
		Subscriptions: []mqtt.SubscribeOptions{
			{Topic: topic, QoS: 0, NoLocal: true},
		},
	})

	if mb.Error == nil {
		if strings.Contains(topic, "#") {
			mb.addWildcard(topic, callback)
			log.Printf("Wildcard subscription added: %s", topic)
		} else {
			if _, ok := mb.Handlers[topic]; !ok {
				mb.Handlers[topic] = callback
			}
			log.Printf("Regular subscription added: %s", topic)
		}
	}

	return mb.Error
}

// Look through the truncated topics in the wildcard handlers list to see
// if the specified topic matches
func (mb *MqttMessageBroker) checkWildcard(topic string) (handler IMessageHandler, ok bool) {
	for _, entry := range mb.WildcardHandlers {
		if strings.HasPrefix(topic, entry.prefix) {
			return entry.handler, true
		}
	}

	return handler, false
}

// Adds a handler for a specific prefix topic (wildcard)
func (mb *MqttMessageBroker) addWildcard(topic string, handler IMessageHandler) {
	prefix := strings.Split(topic, "#")[0]
	if _, ok := mb.checkWildcard(prefix); !ok {
		entry := MqttWildcardEntry{topic: topic, prefix: prefix, handler: handler}
		mb.WildcardHandlers = append(mb.WildcardHandlers, entry)
	}
}
